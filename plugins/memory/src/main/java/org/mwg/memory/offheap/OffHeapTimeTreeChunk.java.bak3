package org.mwg.memory.offheap;

import org.mwg.Constants;
import org.mwg.chunk.ChunkType;
import org.mwg.chunk.TimeTreeChunk;
import org.mwg.chunk.TreeWalker;
import org.mwg.struct.Buffer;
import org.mwg.utility.Base64;

class OffHeapTimeTreeChunk implements TimeTreeChunk {

    private static final int META_SIZE = 3;
    private static final byte TRUE = 1;
    private static final byte FALSE = 0;

    private static final int LOCK = 0;
    private static final int MAGIC = 1;
    private static final int METAS = 2;
    private static final int K = 3;
    private static final int COLORS = 4;
    private static final int SIZE = 5;
    private static final int CAPACITY = 6;
    private static final int DIRTY = 7;
    private static final int ROOT = 8;

    private static final int CHUNK_SIZE = 9;

    private final OffHeapChunkSpace space;
    private final long index;
    private final long addr;

    OffHeapTimeTreeChunk(final OffHeapChunkSpace p_space, final long p_index) {
        space = p_space;
        index = p_index;
        long temp_addr = space.addrByIndex(index);
        if (temp_addr == OffHeapConstants.OFFHEAP_NULL_PTR) {
            temp_addr = OffHeapLongArray.allocate(CHUNK_SIZE);
            space.setAddrByIndex(index, temp_addr);
            //init the initial values
            OffHeapLongArray.set(temp_addr, LOCK, 0);
            OffHeapLongArray.set(temp_addr, MAGIC, 0);
            OffHeapLongArray.set(temp_addr, CAPACITY, 0);
            OffHeapLongArray.set(temp_addr, SIZE, 0);
            OffHeapLongArray.set(temp_addr, DIRTY, 0);
            OffHeapLongArray.set(temp_addr, ROOT, -1);
            OffHeapLongArray.set(temp_addr, K, OffHeapConstants.OFFHEAP_NULL_PTR);
            OffHeapLongArray.set(temp_addr, COLORS, OffHeapConstants.OFFHEAP_NULL_PTR);
            OffHeapLongArray.set(temp_addr, METAS, OffHeapConstants.OFFHEAP_NULL_PTR);
        }
        addr = temp_addr;
    }

    public static void free(final long addr) {
        if (addr != OffHeapConstants.OFFHEAP_NULL_PTR) {
            OffHeapLongArray.free(OffHeapLongArray.get(addr, K));
            OffHeapLongArray.free(OffHeapLongArray.get(addr, COLORS));
            OffHeapLongArray.free(OffHeapLongArray.get(addr, METAS));
            OffHeapLongArray.free(addr);
        }
    }

    @Override
    public final long world() {
        return space.worldByIndex(index);
    }

    @Override
    public final long time() {
        return space.timeByIndex(index);
    }

    @Override
    public final long id() {
        return space.idByIndex(index);
    }

    @Override
    public final long size() {
        return OffHeapLongArray.get(addr, SIZE);
    }

    @Override
    public final long index() {
        return index;
    }

    @Override
    public final long magic() {
        return OffHeapLongArray.get(addr, MAGIC);
    }

    @Override
    public synchronized final void range(final long startKey, final long endKey, final long maxElements, final TreeWalker walker) {
        //lock and load fromVar main memory
        long nbElements = 0;
        final long k_addr = OffHeapLongArray.get(addr, K);
        final long metas_addr = OffHeapLongArray.get(addr, K);
        long indexEnd = internal_previousOrEqual_index(endKey, k_addr, metas_addr);
        while (indexEnd != -1 && OffHeapLongArray.get(k_addr, indexEnd) >= startKey && nbElements < maxElements) {
            walker.elem(OffHeapLongArray.get(k_addr, indexEnd));
            nbElements++;
            indexEnd = previous(indexEnd, metas_addr);
        }
    }

    @Override
    public synchronized final void save(Buffer buffer) {
        final long size = OffHeapLongArray.get(addr, SIZE);
        final long k_addr = OffHeapLongArray.get(addr, K);
        Base64.encodeLongToBuffer(size, buffer);
        buffer.write(Constants.CHUNK_SEP);
        boolean isFirst = true;
        for (long i = 0; i < size; i++) {
            if (!isFirst) {
                buffer.write(Constants.CHUNK_SUB_SEP);
            } else {
                isFirst = false;
            }
            Base64.encodeLongToBuffer(OffHeapLongArray.get(k_addr, i), buffer);
        }
        OffHeapLongArray.set(addr, DIRTY, 0);
    }

    @Override
    public synchronized final void load(Buffer buffer) {
        if (buffer == null || buffer.length() == 0) {
            return;
        }
        final boolean initial = (OffHeapLongArray.get(addr, K) == OffHeapConstants.OFFHEAP_NULL_PTR);
        boolean isDirty = false;
        long cursor = 0;
        long previous = 0;
        long payloadSize = buffer.length();
        while (cursor < payloadSize) {
            byte current = buffer.read(cursor);
            if (current == Constants.CHUNK_SUB_SEP) {
                isDirty = isDirty || internal_insert(Base64.decodeToLongWithBounds(buffer, previous, cursor));
                previous = cursor + 1;
            } else if (current == Constants.CHUNK_SEP) {
                reallocate(OffHeapLongArray.get(addr, CAPACITY), Base64.decodeToLongWithBounds(buffer, previous, cursor));
                previous = cursor + 1;
            }
            cursor++;
        }
        isDirty = isDirty || internal_insert(Base64.decodeToLongWithBounds(buffer, previous, cursor));
        if (isDirty && !initial && OffHeapLongArray.get(addr, DIRTY) != 1) {
            OffHeapLongArray.set(addr, DIRTY, 1);
            if (space != null) {
                space.notifyUpdate(index);
            }
        }
    }

    @Override
    public synchronized final long previousOrEqual(long key) {
        //lock and load fromVar main memory
        final long k_addr = OffHeapLongArray.get(addr, K);
        final long metas_addr = OffHeapLongArray.get(addr, METAS);
        long resultKey;
        long result = internal_previousOrEqual_index(key, k_addr, metas_addr);
        if (result != -1) {
            resultKey = OffHeapLongArray.get(k_addr, result);
        } else {
            resultKey = Constants.NULL_LONG;
        }
        return resultKey;
    }

    @Override
    public synchronized final void insert(final long p_key) {
        if (internal_insert(p_key)) {
            internal_set_dirty();
        }
    }

    @Override
    public synchronized final void unsafe_insert(final long p_key) {
        internal_insert(p_key);
    }

    @Override
    public final byte chunkType() {
        return ChunkType.TIME_TREE_CHUNK;
    }

    @Override
    public synchronized final void clearAt(long max) {
        //lock and load fromVar main memory

        /*
        long[] previousValue = _k;
        //reset the state
        _k = new long[_k.length];
        _back_meta = new int[_k.length * META_SIZE];
        _colors = new boolean[_k.length];
        _root = -1;
        long _previousSize = OffHeapLongArray.get(addr,SIZE);
        _size = 0;
        for (long i = 0; i < _previousSize; i++) {
            if (previousValue[i] != Constants.NULL_LONG && previousValue[i] < max) {
                internal_insert(previousValue[i]);
            }
        }
        */

        //dirty
        internal_set_dirty();
    }

    private void reallocate(long previousCapacity, long newCapacity) {
        if (previousCapacity < newCapacity) {
            long k_addr = OffHeapLongArray.get(addr, K);
            long next_k_addr;
            if (k_addr == OffHeapConstants.OFFHEAP_NULL_PTR) {
                next_k_addr = OffHeapLongArray.allocate(newCapacity);
            } else {
                next_k_addr = OffHeapLongArray.reallocate(k_addr, previousCapacity, newCapacity);
            }
            if (k_addr != next_k_addr) {
                OffHeapLongArray.set(addr, K, next_k_addr);
            }
            long colors_addr = OffHeapLongArray.get(addr, COLORS);
            long next_colors_addr;
            if (colors_addr == OffHeapConstants.OFFHEAP_NULL_PTR) {
                next_colors_addr = OffHeapByteArray.allocate(newCapacity);
            } else {
                next_colors_addr = OffHeapByteArray.reallocate(colors_addr, previousCapacity, newCapacity);
            }
            if (colors_addr != next_colors_addr) {
                OffHeapLongArray.set(addr, COLORS, next_colors_addr);
            }
            long metas_addr = OffHeapLongArray.get(addr, METAS);
            long next_metas_addr;
            if (metas_addr == OffHeapConstants.OFFHEAP_NULL_PTR) {
                next_metas_addr = OffHeapByteArray.allocate(newCapacity);
            } else {
                next_metas_addr = OffHeapByteArray.reallocate(metas_addr, previousCapacity, newCapacity);
            }
            if (metas_addr != next_metas_addr) {
                OffHeapLongArray.set(addr, METAS, next_metas_addr);
            }
        }
    }

    private long left(long p_currentIndex, long metas_addr) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(metas_addr, p_currentIndex * META_SIZE);
    }

    private void setLeft(long p_currentIndex, long p_paramIndex, long metas_addr) {
        OffHeapLongArray.set(metas_addr, p_currentIndex * META_SIZE, p_paramIndex);
    }

    private long right(long p_currentIndex, long metas_addr) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(metas_addr, p_currentIndex * META_SIZE + 1);
    }

    private void setRight(long p_currentIndex, long p_paramIndex, long metas_addr) {
        OffHeapLongArray.set(metas_addr, p_currentIndex * META_SIZE + 1, p_paramIndex);
    }

    private long parent(long p_currentIndex, long metas_addr) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(metas_addr, p_currentIndex * META_SIZE + 2);
    }

    private void setParent(long p_currentIndex, long p_paramIndex, long metas_addr) {
        OffHeapLongArray.set(metas_addr, p_currentIndex * META_SIZE + 2, p_paramIndex);
    }


    private long grandParent(long p_currentIndex, long metas_addr) {
        if (p_currentIndex == -1) {
            return -1;
        }
        if (parent(p_currentIndex, metas_addr) != -1) {
            return parent(parent(p_currentIndex, metas_addr), metas_addr);
        } else {
            return -1;
        }
    }

    private long sibling(long p_currentIndex, long metas_addr) {
        if (parent(p_currentIndex, metas_addr) == -1) {
            return -1;
        } else {
            if (p_currentIndex == left(parent(p_currentIndex, metas_addr), metas_addr)) {
                return right(parent(p_currentIndex, metas_addr), metas_addr);
            } else {
                return left(parent(p_currentIndex, metas_addr), metas_addr);
            }
        }
    }

    private long uncle(long p_currentIndex, long metas_addr) {
        if (parent(p_currentIndex, metas_addr) != -1) {
            return sibling(parent(p_currentIndex, metas_addr), metas_addr);
        } else {
            return -1;
        }
    }

    private long previous(long p_index, long metas_addr) {
        long p = p_index;
        if (left(p, metas_addr) != -1) {
            p = left(p, metas_addr);
            while (right(p, metas_addr) != -1) {
                p = right(p, metas_addr);
            }
            return p;
        } else {
            if (parent(p, metas_addr) != -1) {
                if (p == right(parent(p, metas_addr), metas_addr)) {
                    return parent(p, metas_addr);
                } else {
                    while (parent(p, metas_addr) != -1 && p == left(parent(p, metas_addr), metas_addr)) {
                        p = parent(p, metas_addr);
                    }
                    return parent(p, metas_addr);
                }
            } else {
                return -1;
            }
        }
    }

    /*
    private int next(int p_index) {
        int p = p_index;
        if (right(p) != -1) {
            p = right(p);
            while (left(p) != -1) {
                p = left(p);
            }
            return p;
        } else {
            if (parent(p) != -1) {
                if (p == left(parent(p))) {
                    return parent(p);
                } else {
                    while (parent(p) != -1 && p == right(parent(p))) {
                        p = parent(p);
                    }
                    return parent(p);
                }

            } else {
                return -1;
            }
        }
    }

    private long lookup(long p_key) {
        int n = _root;
        if (n == -1) {
            return CoreConstants.NULL_LONG;
        }
        while (n != -1) {
            if (p_key == key(n)) {
                return key(n);
            } else {
                if (p_key < key(n)) {
                    n = left(n);
                } else {
                    n = right(n);
                }
            }
        }
        return n;
    }
    */


    private long internal_previousOrEqual_index(long p_key, long k_addr, long metas_Addr) {
        long p = OffHeapLongArray.get(addr, ROOT);
        if (p == -1) {
            return p;
        }
        while (p != -1) {
            long k_p = OffHeapLongArray.get(k_addr, p);
            if (p_key == k_p) {
                return p;
            }
            if (p_key > k_p) {
                if (right(p, metas_Addr) != -1) {
                    p = right(p, metas_Addr);
                } else {
                    return p;
                }
            } else {
                if (left(p, metas_Addr) != -1) {
                    p = left(p, metas_Addr);
                } else {
                    long parent = parent(p, metas_Addr);
                    long ch = p;
                    while (parent != -1 && ch == left(parent, metas_Addr)) {
                        ch = parent;
                        parent = parent(parent, metas_Addr);
                    }
                    return parent;
                }
            }
        }
        return -1;
    }

    private void rotateLeft(long n, long metas_addr) {
        long r = right(n, metas_addr);
        replaceNode(n, r, metas_addr);
        setRight(n, left(r, metas_addr), metas_addr);
        if (left(r, metas_addr) != -1) {
            setParent(left(r, metas_addr), n, metas_addr);
        }
        setLeft(r, n, metas_addr);
        setParent(n, r, metas_addr);
    }

    private void rotateRight(long n, long metas_addr) {
        long l = left(n, metas_addr);
        replaceNode(n, l, metas_addr);
        setLeft(n, right(l, metas_addr), metas_addr);
        if (right(l, metas_addr) != -1) {
            setParent(right(l, metas_addr), n, metas_addr);
        }
        setRight(l, n, metas_addr);
        setParent(n, l, metas_addr);
    }

    private void replaceNode(long oldn, long newn, long metas_addr) {
        if (parent(oldn, metas_addr) == -1) {
            OffHeapLongArray.set(addr, ROOT, newn);
        } else {
            if (oldn == left(parent(oldn, metas_addr), metas_addr)) {
                setLeft(parent(oldn, metas_addr), newn, metas_addr);
            } else {
                setRight(parent(oldn, metas_addr), newn, metas_addr);
            }
        }
        if (newn != -1) {
            setParent(newn, parent(oldn, metas_addr), metas_addr);
        }
    }

    private void insertCase1(long n, long colors_addr, long metas_addr) {
        if (parent(n, metas_addr) == -1) {
            OffHeapByteArray.set(colors_addr, n, TRUE);
        } else {
            insertCase2(n, colors_addr, metas_addr);
        }
    }

    private void insertCase2(long n, long colors_addr, long metas_addr) {
        if (OffHeapByteArray.get(colors_addr, parent(n, metas_addr)) == FALSE) {
            insertCase3(n, colors_addr, metas_addr);
        }
    }

    private void insertCase3(long n, long colors_addr, long metas_addr) {
        if (OffHeapByteArray.get(colors_addr, uncle(n, metas_addr)) == FALSE) {

            OffHeapByteArray.set(colors_addr, parent(n, metas_addr), TRUE);
            OffHeapByteArray.set(colors_addr, uncle(n, metas_addr), TRUE);
            OffHeapByteArray.set(colors_addr, grandParent(n, metas_addr), FALSE);
            insertCase1(grandParent(n, metas_addr), colors_addr, metas_addr);
        } else {
            insertCase4(n, colors_addr, metas_addr);
        }
    }

    private void insertCase4(long n_n, long colors_addr, long metas_addr) {
        long n = n_n;
        if (n == right(parent(n, metas_addr), metas_addr) && parent(n, metas_addr) == left(grandParent(n, metas_addr), metas_addr)) {
            rotateLeft(parent(n, metas_addr), metas_addr);
            n = left(n, metas_addr);
        } else {
            if (n == left(parent(n, metas_addr), metas_addr) && parent(n, metas_addr) == right(grandParent(n, metas_addr), metas_addr)) {
                rotateRight(parent(n, metas_addr), metas_addr);
                n = right(n, metas_addr);
            }
        }
        insertCase5(n, colors_addr, metas_addr);
    }

    private void insertCase5(long n, long colors_addr, long metas_addr) {
        OffHeapByteArray.set(colors_addr, parent(n, metas_addr), TRUE);
        OffHeapByteArray.set(colors_addr, grandParent(n, metas_addr), FALSE);
        if (n == left(parent(n, metas_addr), metas_addr) && parent(n, metas_addr) == left(grandParent(n, metas_addr), metas_addr)) {
            rotateRight(grandParent(n, metas_addr), metas_addr);
        } else {
            rotateLeft(grandParent(n, metas_addr), metas_addr);
        }
    }

    private boolean internal_insert(long p_key) {
        long size = OffHeapLongArray.get(addr, SIZE);
        long capacity = OffHeapLongArray.get(addr, CAPACITY);
        long k_addr = OffHeapLongArray.get(addr, K);
        long colors_addr = OffHeapLongArray.get(addr, COLORS);
        long metas_addr = OffHeapLongArray.get(addr, METAS);
        if (k_addr == OffHeapConstants.OFFHEAP_NULL_PTR || size == capacity) {
            long length = size;
            if (length == 0) {
                length = Constants.MAP_INITIAL_CAPACITY;
            } else {
                length = length * 2;
            }
            reallocate(capacity, length);
            k_addr = OffHeapLongArray.get(addr, K);
            capacity = OffHeapLongArray.get(addr, CAPACITY);
            size = OffHeapLongArray.get(addr, SIZE);
            colors_addr = OffHeapLongArray.get(addr, COLORS);
            metas_addr = OffHeapLongArray.get(addr, METAS);
        }
        long newIndex = size;
        if (newIndex == 0) {
            OffHeapLongArray.set(k_addr, newIndex, p_key);
            OffHeapByteArray.set(colors_addr, newIndex, FALSE);
            setLeft(newIndex, -1, metas_addr);
            setRight(newIndex, -1, metas_addr);
            setParent(newIndex, -1, metas_addr);
            OffHeapLongArray.set(addr, ROOT, newIndex);
            size = 1;
            OffHeapLongArray.set(addr, SIZE, size);
        } else {
            long n = OffHeapLongArray.get(addr, ROOT);
            while (true) {
                long k_n = OffHeapLongArray.get(k_addr, n);
                if (p_key == k_n) {
                    return false;
                } else if (p_key < k_n) {
                    if (left(n, metas_addr) == -1) {
                        OffHeapLongArray.set(k_addr, newIndex, p_key);
                        OffHeapByteArray.set(colors_addr, newIndex, FALSE);
                        setLeft(newIndex, -1, metas_addr);
                        setRight(newIndex, -1, metas_addr);
                        setParent(newIndex, -1, metas_addr);
                        setLeft(n, newIndex, metas_addr);
                        size++;
                        OffHeapLongArray.set(addr, SIZE, size);
                        break;
                    } else {
                        n = left(n, metas_addr);
                    }
                } else {
                    if (right(n, metas_addr) == -1) {
                        OffHeapLongArray.set(k_addr, newIndex, p_key);
                        OffHeapByteArray.set(colors_addr, newIndex, FALSE);
                        setLeft(newIndex, -1, metas_addr);
                        setRight(newIndex, -1, metas_addr);
                        setParent(newIndex, -1, metas_addr);
                        setRight(n, newIndex, metas_addr);
                        size++;
                        OffHeapLongArray.set(addr, SIZE, size);
                        break;
                    } else {
                        n = right(n, metas_addr);
                    }
                }
            }
            setParent(newIndex, n, metas_addr);
        }
        insertCase1(newIndex, colors_addr, metas_addr);
        return true;
    }

    private void internal_set_dirty() {
        OffHeapLongArray.set(addr, MAGIC, OffHeapLongArray.get(addr, MAGIC) + 1);
        if (space != null && OffHeapLongArray.get(addr, DIRTY) != 1) {
            OffHeapLongArray.set(addr, DIRTY, 1);
            space.notifyUpdate(index);
        }
    }

     /*
    public void delete(long key) {
        TreeNode n = lookup(key);
        if (n == null) {
            return;
        } else {
            _size--;
            if (n.getLeft() != null && n.getRight() != null) {
                // Copy domainKey/value fromVar predecessor and done delete it instead
                TreeNode pred = n.getLeft();
                while (pred.getRight() != null) {
                    pred = pred.getRight();
                }
                n.key = pred.key;
                n = pred;
            }
            TreeNode child;
            if (n.getRight() == null) {
                child = n.getLeft();
            } else {
                child = n.getRight();
            }
            if (nodeColor(n) == true) {
                n.color = nodeColor(child);
                deleteCase1(n);
            }
            replaceNode(n, child);
        }
    }

    private void deleteCase1(TreeNode n) {
        if (n.getParent() == null) {
            return;
        } else {
            deleteCase2(n);
        }
    }

    private void deleteCase2(TreeNode n) {
        if (nodeColor(n.sibling()) == false) {
            n.getParent().color = false;
            n.sibling().color = true;
            if (n == n.getParent().getLeft()) {
                rotateLeft(n.getParent());
            } else {
                rotateRight(n.getParent());
            }
        }
        deleteCase3(n);
    }

    private void deleteCase3(TreeNode n) {
        if (nodeColor(n.getParent()) == true && nodeColor(n.sibling()) == true && nodeColor(n.sibling().getLeft()) == true && nodeColor(n.sibling().getRight()) == true) {
            n.sibling().color = false;
            deleteCase1(n.getParent());
        } else {
            deleteCase4(n);
        }
    }

    private void deleteCase4(TreeNode n) {
        if (nodeColor(n.getParent()) == false && nodeColor(n.sibling()) == true && nodeColor(n.sibling().getLeft()) == true && nodeColor(n.sibling().getRight()) == true) {
            n.sibling().color = false;
            n.getParent().color = true;
        } else {
            deleteCase5(n);
        }
    }

    private void deleteCase5(TreeNode n) {
        if (n == n.getParent().getLeft() && nodeColor(n.sibling()) == true && nodeColor(n.sibling().getLeft()) == false && nodeColor(n.sibling().getRight()) == true) {
            n.sibling().color = false;
            n.sibling().getLeft().color = true;
            rotateRight(n.sibling());
        } else if (n == n.getParent().getRight() && nodeColor(n.sibling()) == true && nodeColor(n.sibling().getRight()) == false && nodeColor(n.sibling().getLeft()) == true) {
            n.sibling().color = false;
            n.sibling().getRight().color = true;
            rotateLeft(n.sibling());
        }
        deleteCase6(n);
    }

    private void deleteCase6(TreeNode n) {
        n.sibling().color = nodeColor(n.getParent());
        n.getParent().color = true;
        if (n == n.getParent().getLeft()) {
            n.sibling().getRight().color = true;
            rotateLeft(n.getParent());
        } else {
            n.sibling().getLeft().color = true;
            rotateRight(n.getParent());
        }
    }*/

}
