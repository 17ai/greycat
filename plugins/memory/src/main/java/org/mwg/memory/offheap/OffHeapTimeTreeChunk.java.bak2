package org.mwg.memory.offheap;

import org.mwg.Constants;
import org.mwg.chunk.ChunkListener;
import org.mwg.chunk.TimeTreeChunk;
import org.mwg.chunk.TreeWalker;
import org.mwg.utility.Base64;
import org.mwg.chunk.ChunkType;
import org.mwg.struct.Buffer;
import org.mwg.utility.HashHelper;

public class OffHeapTimeTreeChunk implements TimeTreeChunk, {

    private static final int META_SIZE = 3;
    private static final byte TRUE = 1;
    private static final byte FALSE = 0;

    private static final int LOCK = 0;
    private static final int MAGIC = 1;
    private static final int METAS = 2;
    private static final int K = 3;
    private static final int COLORS = 4;
    private static final int SIZE = 5;
    private static final int CAPACITY = 6;
    private static final int DIRTY = 7;
    private static final int ROOT = 8;

    private static final int CHUNK_SIZE = 9;

    private final OffHeapChunkSpace space;
    private final long index;
    private final long addr;

    OffHeapTimeTreeChunk(final OffHeapChunkSpace p_space, final long p_index) {
        space = p_space;
        index = p_index;
        long temp_addr = space.addrByIndex(index);
        if (temp_addr == OffHeapConstants.OFFHEAP_NULL_PTR) {
            temp_addr = OffHeapLongArray.allocate(CHUNK_SIZE);
            space.setAddrByIndex(index, temp_addr);
            //init the initial values
            OffHeapLongArray.set(temp_addr, LOCK, 0);
            OffHeapLongArray.set(temp_addr, MAGIC, 0);
            OffHeapLongArray.set(temp_addr, CAPACITY, 0);
            OffHeapLongArray.set(temp_addr, SIZE, 0);
            OffHeapLongArray.set(temp_addr, DIRTY, 0);
            OffHeapLongArray.set(temp_addr, ROOT, -1);
            OffHeapLongArray.set(temp_addr, K, OffHeapConstants.OFFHEAP_NULL_PTR);
            OffHeapLongArray.set(temp_addr, COLORS, OffHeapConstants.OFFHEAP_NULL_PTR);
            OffHeapLongArray.set(temp_addr, METAS, OffHeapConstants.OFFHEAP_NULL_PTR);
        }
        addr = temp_addr;
    }

    public OffHeapTimeTreeChunk(ChunkListener p_listener, long previousAddr, Buffer initialPayload) {
        //listener
        this._listener = p_listener;
        //init
        if (previousAddr != OffHeapConstants.OFFHEAP_NULL_PTR) {
            addr = previousAddr;
        } else if (initialPayload != null && initialPayload.length() > 0) {
            addr = OffHeapLongArray.allocate(14);
            load(initialPayload);
        } else {
            addr = OffHeapLongArray.allocate(14);
            long capacity = Constants.MAP_INITIAL_CAPACITY;
            //init k array
            kPtr = OffHeapLongArray.allocate(capacity);
            OffHeapLongArray.set(addr, K, kPtr);
            //init meta array
            metaPtr = OffHeapLongArray.allocate(capacity * META_SIZE);
            OffHeapLongArray.set(addr, META, metaPtr);
            //init colors array
            colorsPtr = OffHeapByteArray.allocate(capacity);
            OffHeapLongArray.set(addr, COLORS, colorsPtr);

            OffHeapLongArray.set(addr, LOCK, 0);
            OffHeapLongArray.set(addr, SIZE, 0);
            OffHeapLongArray.set(addr, ROOT, -1);
            OffHeapLongArray.set(addr, THRESHOLD, (long) (capacity * Constants.MAP_LOAD_FACTOR));
            OffHeapLongArray.set(addr, MAGIC, 0);
        }
    }

    @Override
    public final void clearAt(long max) {
        while (!OffHeapLongArray.compareAndSwap(addr, LOCK, 0, 1)) ;
        try {
            ptrConsistency();
            long previousKeys = OffHeapLongArray.get(addr, K);
            long previousMetas = OffHeapLongArray.get(addr, META);
            long previousColors = OffHeapLongArray.get(addr, COLORS);
            long previousSize = OffHeapLongArray.get(addr, SIZE);

            //reset
            long capacity = Constants.MAP_INITIAL_CAPACITY;
            //init k array
            kPtr = OffHeapLongArray.allocate(capacity);
            OffHeapLongArray.set(addr, K, kPtr);
            //init meta array
            metaPtr = OffHeapLongArray.allocate(capacity * META_SIZE);
            OffHeapLongArray.set(addr, META, metaPtr);
            //init colors array
            colorsPtr = OffHeapByteArray.allocate(capacity);
            OffHeapLongArray.set(addr, COLORS, colorsPtr);

            OffHeapLongArray.set(addr, SIZE, 0);
            OffHeapLongArray.set(addr, ROOT, -1);
            OffHeapLongArray.set(addr, THRESHOLD, (long) (capacity * Constants.MAP_LOAD_FACTOR));
            //TODO replace by any other number
            OffHeapLongArray.set(addr, MAGIC, HashHelper.rand());

            for (long i = 0; i < previousSize; i++) {
                long currentVal = OffHeapLongArray.get(previousKeys, i);
                if (currentVal < max) {
                    internal_insert(OffHeapLongArray.get(previousKeys, i));
                }
            }

            OffHeapLongArray.free(previousKeys);
            OffHeapLongArray.free(previousMetas);
            OffHeapByteArray.free(previousColors);
        } finally {
            //Free OffHeap lock
            if (!OffHeapLongArray.compareAndSwap(addr, LOCK, 1, 0)) {
                throw new RuntimeException("CAS Error !!!");
            }
        }
        internal_set_dirty();
    }

    public static void free(long addr) {
        OffHeapLongArray.free(OffHeapLongArray.get(addr, K));
        OffHeapLongArray.free(OffHeapLongArray.get(addr, META));
        OffHeapByteArray.free(OffHeapLongArray.get(addr, COLORS));
        OffHeapLongArray.free(addr);
    }

    @Override
    public final long magic() {
        return OffHeapLongArray.get(addr, MAGIC);
    }

    @Override
    public final byte chunkType() {
        return ChunkType.TIME_TREE_CHUNK;
    }

    @Override
    public final long addr() {
        return this.addr;
    }

    @Override
    public void setIndex(long index) {
        this.index = index;
    }

    @Override
    public final long marks() {
        return OffHeapLongArray.get(addr, INDEX_MARKS);
    }

    @Override
    public final long world() {
        return OffHeapLongArray.get(addr, INDEX_WORLD);
    }

    @Override
    public final long time() {
        return OffHeapLongArray.get(addr, INDEX_TIME);
    }

    @Override
    public final long id() {
        return OffHeapLongArray.get(addr, INDEX_ID);
    }

    @Override
    public final long flags() {
        return OffHeapLongArray.get(addr, INDEX_FLAGS);
    }

    @Override
    public final long size() {
        return OffHeapLongArray.get(addr, SIZE);
    }

    @Override
    public final void range(long startKey, long endKey, long maxElements, TreeWalker walker) {
        while (!OffHeapLongArray.compareAndSwap(addr, LOCK, 0, 1)) ;
        try {
            ptrConsistency();

            long nbElements = 0;
            long indexEnd = internal_previousOrEqual_index(endKey);
            while (indexEnd != -1 && key(indexEnd) >= startKey && nbElements < maxElements) {
                walker.elem(key(indexEnd));
                nbElements++;
                indexEnd = previous(indexEnd);
            }

        } finally {
            //Free OffHeap lock
            if (!OffHeapLongArray.compareAndSwap(addr, LOCK, 1, 0)) {
                throw new RuntimeException("CAS Error !!!");
            }
        }
    }

    @Override
    public final long previousOrEqual(long key) {
        while (!OffHeapLongArray.compareAndSwap(addr, LOCK, 0, 1)) ;
        try {
            ptrConsistency();
            long result = internal_previousOrEqual_index(key);
            long resultKey;
            if (result != -1) {
                resultKey = key(result);
            } else {
                resultKey = Constants.NULL_LONG;
            }
            return resultKey;
        } finally {
            //Free OffHeap lock
            if (!OffHeapLongArray.compareAndSwap(addr, LOCK, 1, 0)) {
                throw new RuntimeException("CAS Error !!!");
            }
        }
    }

    @Override
    public final void save(Buffer buffer) {
        //lock and load fromVar main memory
        while (!OffHeapLongArray.compareAndSwap(addr, LOCK, 0, 1)) ;
        try {
            ptrConsistency();
            if (OffHeapLongArray.get(addr, ROOT) == OffHeapConstants.OFFHEAP_NULL_PTR) {
                return;
            }
            long treeSize = OffHeapLongArray.get(addr, SIZE);
            boolean isFirst = true;
            for (int i = 0; i < treeSize; i++) {
                if (!isFirst) {
                    buffer.write(Constants.CHUNK_SUB_SEP);
                } else {
                    isFirst = false;
                }
                Base64.encodeLongToBuffer(OffHeapLongArray.get(kPtr, i), buffer);
            }
        } finally {
            if (!OffHeapLongArray.compareAndSwap(addr, LOCK, 1, 0)) {
                throw new RuntimeException("CAS Error !!!");
            }
        }
    }

    private void ptrConsistency() {
        if (kPtr != OffHeapLongArray.get(addr, K)) {
            kPtr = OffHeapLongArray.get(addr, K);
            metaPtr = OffHeapLongArray.get(addr, META);
            colorsPtr = OffHeapLongArray.get(addr, COLORS);
        }
    }

    @Override
    public final void insert(long p_key) {
        //OffHeap lock
        boolean toDeclareDirty;
        while (!OffHeapLongArray.compareAndSwap(addr, LOCK, 0, 1)) ;
        try {
            ptrConsistency();
            toDeclareDirty = internal_insert(p_key);
        } finally {
            //Free OffHeap lock
            if (!OffHeapLongArray.compareAndSwap(addr, LOCK, 1, 0)) {
                throw new RuntimeException("CAS Error !!!");
            }
        }
        if (toDeclareDirty) {
            internal_set_dirty();
        }
    }

    @Override
    public final void unsafe_insert(long p_key) {
        ptrConsistency();
        internal_insert(p_key);
    }

    private boolean internal_insert(long p_key) {

        long size = OffHeapLongArray.get(addr, SIZE);
        if ((size + 1) > OffHeapLongArray.get(addr, THRESHOLD)) {

            long newLength = (size == 0 ? 1 : size << 1);

            kPtr = OffHeapLongArray.reallocate(kPtr, size, newLength);
            metaPtr = OffHeapLongArray.reallocate(metaPtr, size * META_SIZE, newLength * META_SIZE);
            colorsPtr = OffHeapByteArray.reallocate(colorsPtr, size, newLength);

            OffHeapLongArray.set(addr, K, kPtr);
            OffHeapLongArray.set(addr, META, metaPtr);
            OffHeapLongArray.set(addr, COLORS, colorsPtr);
            OffHeapLongArray.set(addr, THRESHOLD, (long) (newLength * Constants.MAP_LOAD_FACTOR));

        }
        if (size == 0) {
            setKey(size, p_key);
            setColor(size, false);
            setLeft(size, -1);
            setRight(size, -1);
            setParent(size, -1);
            OffHeapLongArray.set(addr, ROOT, size);
            OffHeapLongArray.set(addr, SIZE, 1);
        } else {
            long n = OffHeapLongArray.get(addr, ROOT);
            while (true) {
                if (p_key == key(n)) {
                    return false;
                } else if (p_key < key(n)) {
                    if (left(n) == -1) {
                        setKey(size, p_key);
                        setColor(size, false);
                        setLeft(size, -1);
                        setRight(size, -1);
                        setParent(size, -1);
                        setLeft(n, size);
                        OffHeapLongArray.set(addr, SIZE, size + 1);
                        break;
                    } else {
                        n = left(n);
                    }
                } else {
                    if (right(n) == -1) {
                        setKey(size, p_key);
                        setColor(size, false);
                        setLeft(size, -1);
                        setRight(size, -1);
                        setParent(size, -1);
                        setRight(n, size);
                        OffHeapLongArray.set(addr, SIZE, size + 1);
                        break;
                    } else {
                        n = right(n);
                    }
                }
            }
            setParent(size, n);
        }
        insertCase1(size);
        return true;
    }

    private long internal_previousOrEqual_index(long p_key) {
        long p = OffHeapLongArray.get(addr, ROOT);
        if (p == -1) {
            return p;
        }
        while (p != -1) {
            if (p_key == key(p)) {
                return p;
            }
            if (p_key > key(p)) {
                if (right(p) != -1) {
                    p = right(p);
                } else {
                    return p;
                }
            } else {
                if (left(p) != -1) {
                    p = left(p);
                } else {
                    long parent = parent(p);
                    long ch = p;
                    while (parent != -1 && ch == left(parent)) {
                        ch = parent;
                        parent = parent(parent);
                    }
                    return parent;
                }
            }
        }
        return -1;
    }

    private void internal_set_dirty() {
        long previousMagic;
        long nextMagic;
        do {
            previousMagic = OffHeapLongArray.get(addr, MAGIC);
            nextMagic = previousMagic + 1;
        } while (!OffHeapLongArray.compareAndSwap(addr, MAGIC, previousMagic, nextMagic));
        if (_listener != null) {
            if ((OffHeapLongArray.get(addr, INDEX_FLAGS) & Constants.DIRTY_BIT) != Constants.DIRTY_BIT) {
                _listener.declareDirty(this);
            }
        }
    }

    private long key(long p_currentIndex) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(kPtr, p_currentIndex);
    }

    private void setKey(long p_currentIndex, long p_paramIndex) {
        OffHeapLongArray.set(kPtr, p_currentIndex, p_paramIndex);
    }

    private long left(long p_currentIndex) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(metaPtr, p_currentIndex * META_SIZE);
    }

    private void setLeft(long p_currentIndex, long p_paramIndex) {
        OffHeapLongArray.set(metaPtr, p_currentIndex * META_SIZE, p_paramIndex);
    }

    private long right(long p_currentIndex) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(metaPtr, (p_currentIndex * META_SIZE) + 1);
    }

    private void setRight(long p_currentIndex, long p_paramIndex) {
        OffHeapLongArray.set(metaPtr, (p_currentIndex * META_SIZE) + 1, p_paramIndex);
    }

    private long parent(long p_currentIndex) {
        if (p_currentIndex == -1) {
            return -1;
        }
        return OffHeapLongArray.get(metaPtr, (p_currentIndex * META_SIZE) + 2);
    }

    private void setParent(long p_currentIndex, long p_paramIndex) {
        OffHeapLongArray.set(metaPtr, (p_currentIndex * META_SIZE) + 2, p_paramIndex);
    }

    private boolean color(long p_currentIndex) {
        if (p_currentIndex == -1) {
            return true;
        }
        return OffHeapByteArray.get(colorsPtr, p_currentIndex) == 1;
    }

    private void setColor(long p_currentIndex, boolean p_paramIndex) {
        if (p_paramIndex) {
            OffHeapByteArray.set(colorsPtr, p_currentIndex, (byte) 1);
        } else {
            OffHeapByteArray.set(colorsPtr, p_currentIndex, (byte) 0);
        }
    }

    private long grandParent(long p_currentIndex) {
        if (p_currentIndex == -1) {
            return -1;
        }
        if (parent(p_currentIndex) != -1) {
            return parent(parent(p_currentIndex));
        } else {
            return -1;
        }
    }

    private long sibling(long p_currentIndex) {
        if (parent(p_currentIndex) == -1) {
            return -1;
        } else {
            if (p_currentIndex == left(parent(p_currentIndex))) {
                return right(parent(p_currentIndex));
            } else {
                return left(parent(p_currentIndex));
            }
        }
    }

    private long uncle(long p_currentIndex) {
        if (parent(p_currentIndex) != -1) {
            return sibling(parent(p_currentIndex));
        } else {
            return -1;
        }
    }

    private long previous(long p_index) {
        long p = p_index;
        if (left(p) != -1) {
            p = left(p);
            while (right(p) != -1) {
                p = right(p);
            }
            return p;
        } else {
            if (parent(p) != -1) {
                if (p == right(parent(p))) {
                    return parent(p);
                } else {
                    while (parent(p) != -1 && p == left(parent(p))) {
                        p = parent(p);
                    }
                    return parent(p);
                }
            } else {
                return -1;
            }
        }
    }

    private void rotateLeft(long n) {
        long r = right(n);
        replaceNode(n, r);
        setRight(n, left(r));
        if (left(r) != -1) {
            setParent(left(r), n);
        }
        setLeft(r, n);
        setParent(n, r);
    }

    private void rotateRight(long n) {
        long l = left(n);
        replaceNode(n, l);
        setLeft(n, right(l));
        if (right(l) != -1) {
            setParent(right(l), n);
        }
        setRight(l, n);
        setParent(n, l);
    }

    private void replaceNode(long oldn, long newn) {
        if (parent(oldn) == -1) {
            OffHeapLongArray.set(addr, ROOT, newn);
        } else {
            if (oldn == left(parent(oldn))) {
                setLeft(parent(oldn), newn);
            } else {
                setRight(parent(oldn), newn);
            }
        }
        if (newn != -1) {
            setParent(newn, parent(oldn));
        }
    }

    private void insertCase1(long n) {
        if (parent(n) == -1) {
            setColor(n, true);
        } else {
            insertCase2(n);
        }
    }

    private void insertCase2(long n) {
        if (!color(parent(n))) {
            insertCase3(n);
        }
    }

    private void insertCase3(long n) {
        if (!color(uncle(n))) {
            setColor(parent(n), true);
            setColor(uncle(n), true);
            setColor(grandParent(n), false);
            insertCase1(grandParent(n));
        } else {
            insertCase4(n);
        }
    }

    private void insertCase4(long n_n) {
        long n = n_n;
        if (n == right(parent(n)) && parent(n) == left(grandParent(n))) {
            rotateLeft(parent(n));
            n = left(n);
        } else {
            if (n == left(parent(n)) && parent(n) == right(grandParent(n))) {
                rotateRight(parent(n));
                n = right(n);
            }
        }
        insertCase5(n);
    }

    private void insertCase5(long n) {
        setColor(parent(n), true);
        setColor(grandParent(n), false);
        if (n == left(parent(n)) && parent(n) == left(grandParent(n))) {
            rotateRight(grandParent(n));
        } else {
            rotateLeft(grandParent(n));
        }
    }

    private void load(final Buffer buffer) {

        long capacity = Constants.MAP_INITIAL_CAPACITY;

        //init k array
        kPtr = OffHeapLongArray.allocate(Constants.MAP_INITIAL_CAPACITY);
        OffHeapLongArray.set(addr, K, kPtr);
        //init meta array
        metaPtr = OffHeapLongArray.allocate(Constants.MAP_INITIAL_CAPACITY * META_SIZE);
        OffHeapLongArray.set(addr, META, metaPtr);
        //init colors array
        colorsPtr = OffHeapByteArray.allocate(Constants.MAP_INITIAL_CAPACITY);
        OffHeapLongArray.set(addr, COLORS, colorsPtr);

        OffHeapLongArray.set(addr, LOCK, 0);
        OffHeapLongArray.set(addr, INDEX_FLAGS, 0);
        OffHeapLongArray.set(addr, SIZE, 0);
        OffHeapLongArray.set(addr, ROOT, -1);
        OffHeapLongArray.set(addr, THRESHOLD, (long) (capacity * Constants.MAP_LOAD_FACTOR));
        OffHeapLongArray.set(addr, MAGIC, 0);

        long cursor = 0;
        long previous = 0;
        long payloadSize = buffer.length();
        while (cursor < payloadSize) {
            byte current = buffer.read(cursor);
            if (current == Constants.CHUNK_SUB_SEP) {
                internal_insert(Base64.decodeToLongWithBounds(buffer, previous, cursor));
                previous = cursor + 1;
            }
            cursor++;
        }
        internal_insert(Base64.decodeToLongWithBounds(buffer, previous, cursor));
    }

    @Override
    public void load(Buffer buffer) {
        boolean toDeclareDirty = false;
        while (!OffHeapLongArray.compareAndSwap(addr, LOCK, 0, 1)) ;
        try {
            ptrConsistency();
            //loop
            long cursor = 0;
            long previous = 0;
            long payloadSize = buffer.length();
            while (cursor < payloadSize) {
                byte current = buffer.read(cursor);
                if (current == Constants.CHUNK_SUB_SEP) {
                    toDeclareDirty = toDeclareDirty || internal_insert(Base64.decodeToLongWithBounds(buffer, previous, cursor));
                    previous = cursor + 1;
                }
                cursor++;
            }
            toDeclareDirty = toDeclareDirty || internal_insert(Base64.decodeToLongWithBounds(buffer, previous, cursor));
        } finally {
            //Free OffHeap lock
            if (!OffHeapLongArray.compareAndSwap(addr, LOCK, 1, 0)) {
                throw new RuntimeException("CAS Error !!!");
            }
        }
        if (toDeclareDirty) {
            internal_set_dirty();
        }
    }

    @Override
    public long index() {
        return index;
    }

}
